{"ast":null,"code":"// Check if there's a winner\nexport const checkWinner = board => {\n  const winningCombinations = [[0, 1, 2], [3, 4, 5], [6, 7, 8],\n  // Rows\n  [0, 3, 6], [1, 4, 7], [2, 5, 8],\n  // Columns\n  [0, 4, 8], [2, 4, 6] // Diagonals\n  ];\n  for (let combination of winningCombinations) {\n    const [a, b, c] = combination;\n    if (board[a] && board[a] === board[b] && board[a] === board[c]) {\n      return {\n        winner: board[a],\n        winningCombination: combination\n      };\n    }\n  }\n  return null;\n};\n\n// Check if the board is full (draw)\nexport const isBoardFull = board => {\n  return board.every(cell => cell !== '');\n};\n\n// Get available moves for AI\nexport const getAvailableMoves = board => {\n  return board.map((cell, index) => cell === '' ? index : null).filter(val => val !== null);\n};\n\n// Simple AI move (random for now, can be improved with minimax)\nexport const getAIMove = (board, difficulty = 'easy') => {\n  const availableMoves = getAvailableMoves(board);\n  if (availableMoves.length === 0) return null;\n  switch (difficulty) {\n    case 'easy':\n      return getRandomMove(availableMoves);\n    case 'medium':\n      return getMediumMove(board, availableMoves);\n    case 'hard':\n      return getHardMove(board, availableMoves);\n    default:\n      return getRandomMove(availableMoves);\n  }\n};\n\n// Random AI move\nconst getRandomMove = availableMoves => {\n  return availableMoves[Math.floor(Math.random() * availableMoves.length)];\n};\n\n// Medium AI - blocks obvious wins and takes obvious wins\nconst getMediumMove = (board, availableMoves) => {\n  // First, check if AI can win\n  for (let move of availableMoves) {\n    var _checkWinner;\n    const testBoard = [...board];\n    testBoard[move] = 'O';\n    if (((_checkWinner = checkWinner(testBoard)) === null || _checkWinner === void 0 ? void 0 : _checkWinner.winner) === 'O') {\n      return move;\n    }\n  }\n\n  // Then, check if AI needs to block player from winning\n  for (let move of availableMoves) {\n    var _checkWinner2;\n    const testBoard = [...board];\n    testBoard[move] = 'X';\n    if (((_checkWinner2 = checkWinner(testBoard)) === null || _checkWinner2 === void 0 ? void 0 : _checkWinner2.winner) === 'X') {\n      return move;\n    }\n  }\n\n  // Otherwise, random move\n  return getRandomMove(availableMoves);\n};\n\n// Hard AI - uses minimax algorithm\nconst getHardMove = (board, availableMoves) => {\n  return minimax(board, 0, true).index;\n};\n\n// Minimax algorithm for hard AI\nconst minimax = (board, depth, isMaximizing) => {\n  const winner = checkWinner(board);\n  if ((winner === null || winner === void 0 ? void 0 : winner.winner) === 'O') return {\n    score: 10 - depth\n  };\n  if ((winner === null || winner === void 0 ? void 0 : winner.winner) === 'X') return {\n    score: depth - 10\n  };\n  if (isBoardFull(board)) return {\n    score: 0\n  };\n  const availableMoves = getAvailableMoves(board);\n  if (isMaximizing) {\n    let bestScore = -Infinity;\n    let bestMove = availableMoves[0];\n    for (let move of availableMoves) {\n      const testBoard = [...board];\n      testBoard[move] = 'O';\n      const score = minimax(testBoard, depth + 1, false).score;\n      if (score > bestScore) {\n        bestScore = score;\n        bestMove = move;\n      }\n    }\n    return {\n      score: bestScore,\n      index: bestMove\n    };\n  } else {\n    let bestScore = Infinity;\n    let bestMove = availableMoves[0];\n    for (let move of availableMoves) {\n      const testBoard = [...board];\n      testBoard[move] = 'X';\n      const score = minimax(testBoard, depth + 1, true).score;\n      if (score < bestScore) {\n        bestScore = score;\n        bestMove = move;\n      }\n    }\n    return {\n      score: bestScore,\n      index: bestMove\n    };\n  }\n};\n\n// Initialize empty board\nexport const createEmptyBoard = () => {\n  return new Array(9).fill('');\n};\n\n// Count moves made\nexport const countMoves = board => {\n  return board.filter(cell => cell !== '').length;\n};\n\n// Determine game result from player's perspective\nexport const getGameResult = (winner, playerSymbol) => {\n  if (!winner) return 'draw';\n  return winner === playerSymbol ? 'win' : 'lose';\n};","map":{"version":3,"names":["checkWinner","board","winningCombinations","combination","a","b","c","winner","winningCombination","isBoardFull","every","cell","getAvailableMoves","map","index","filter","val","getAIMove","difficulty","availableMoves","length","getRandomMove","getMediumMove","getHardMove","Math","floor","random","move","_checkWinner","testBoard","_checkWinner2","minimax","depth","isMaximizing","score","bestScore","Infinity","bestMove","createEmptyBoard","Array","fill","countMoves","getGameResult","playerSymbol"],"sources":["/Users/baidikmazumdar/Documents/tic-tac-toe/client/src/utils/gameLogic.js"],"sourcesContent":["// Check if there's a winner\nexport const checkWinner = (board) => {\n  const winningCombinations = [\n    [0, 1, 2], [3, 4, 5], [6, 7, 8], // Rows\n    [0, 3, 6], [1, 4, 7], [2, 5, 8], // Columns\n    [0, 4, 8], [2, 4, 6] // Diagonals\n  ];\n\n  for (let combination of winningCombinations) {\n    const [a, b, c] = combination;\n    if (board[a] && board[a] === board[b] && board[a] === board[c]) {\n      return {\n        winner: board[a],\n        winningCombination: combination\n      };\n    }\n  }\n  return null;\n};\n\n// Check if the board is full (draw)\nexport const isBoardFull = (board) => {\n  return board.every(cell => cell !== '');\n};\n\n// Get available moves for AI\nexport const getAvailableMoves = (board) => {\n  return board.map((cell, index) => cell === '' ? index : null).filter(val => val !== null);\n};\n\n// Simple AI move (random for now, can be improved with minimax)\nexport const getAIMove = (board, difficulty = 'easy') => {\n  const availableMoves = getAvailableMoves(board);\n  \n  if (availableMoves.length === 0) return null;\n\n  switch (difficulty) {\n    case 'easy':\n      return getRandomMove(availableMoves);\n    case 'medium':\n      return getMediumMove(board, availableMoves);\n    case 'hard':\n      return getHardMove(board, availableMoves);\n    default:\n      return getRandomMove(availableMoves);\n  }\n};\n\n// Random AI move\nconst getRandomMove = (availableMoves) => {\n  return availableMoves[Math.floor(Math.random() * availableMoves.length)];\n};\n\n// Medium AI - blocks obvious wins and takes obvious wins\nconst getMediumMove = (board, availableMoves) => {\n  // First, check if AI can win\n  for (let move of availableMoves) {\n    const testBoard = [...board];\n    testBoard[move] = 'O';\n    if (checkWinner(testBoard)?.winner === 'O') {\n      return move;\n    }\n  }\n\n  // Then, check if AI needs to block player from winning\n  for (let move of availableMoves) {\n    const testBoard = [...board];\n    testBoard[move] = 'X';\n    if (checkWinner(testBoard)?.winner === 'X') {\n      return move;\n    }\n  }\n\n  // Otherwise, random move\n  return getRandomMove(availableMoves);\n};\n\n// Hard AI - uses minimax algorithm\nconst getHardMove = (board, availableMoves) => {\n  return minimax(board, 0, true).index;\n};\n\n// Minimax algorithm for hard AI\nconst minimax = (board, depth, isMaximizing) => {\n  const winner = checkWinner(board);\n  \n  if (winner?.winner === 'O') return { score: 10 - depth };\n  if (winner?.winner === 'X') return { score: depth - 10 };\n  if (isBoardFull(board)) return { score: 0 };\n\n  const availableMoves = getAvailableMoves(board);\n  \n  if (isMaximizing) {\n    let bestScore = -Infinity;\n    let bestMove = availableMoves[0];\n    \n    for (let move of availableMoves) {\n      const testBoard = [...board];\n      testBoard[move] = 'O';\n      const score = minimax(testBoard, depth + 1, false).score;\n      \n      if (score > bestScore) {\n        bestScore = score;\n        bestMove = move;\n      }\n    }\n    \n    return { score: bestScore, index: bestMove };\n  } else {\n    let bestScore = Infinity;\n    let bestMove = availableMoves[0];\n    \n    for (let move of availableMoves) {\n      const testBoard = [...board];\n      testBoard[move] = 'X';\n      const score = minimax(testBoard, depth + 1, true).score;\n      \n      if (score < bestScore) {\n        bestScore = score;\n        bestMove = move;\n      }\n    }\n    \n    return { score: bestScore, index: bestMove };\n  }\n};\n\n// Initialize empty board\nexport const createEmptyBoard = () => {\n  return new Array(9).fill('');\n};\n\n// Count moves made\nexport const countMoves = (board) => {\n  return board.filter(cell => cell !== '').length;\n};\n\n// Determine game result from player's perspective\nexport const getGameResult = (winner, playerSymbol) => {\n  if (!winner) return 'draw';\n  return winner === playerSymbol ? 'win' : 'lose';\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}